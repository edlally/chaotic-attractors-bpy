"""
Operator classes and utility functions for chaotic attractors
"""
import bpy
import random
import time
import mathutils
import numpy as np
from bpy.types import Operator
from . import simulation, materials, attractors, handlers


def get_chaos_collection():
    """Get or create the chaos collection"""
    chaos_collection_name = "Chaotic_Attractors"
    if chaos_collection_name in bpy.data.collections:
        return bpy.data.collections[chaos_collection_name]
    else:
        chaos_collection = bpy.data.collections.new(chaos_collection_name)
        bpy.context.scene.collection.children.link(chaos_collection)
        return chaos_collection


def create_geometry_nodes_instancer(obj, particle_obj, material):
    """Create geometry nodes instancer for optimized particle animation"""
    node_group = bpy.data.node_groups.new("OptimizedParticleInstancer", 'GeometryNodeTree')
    # Create interface sockets: only one for Geometry (INPUT) and one for Geometry (OUTPUT)
    node_group.interface.new_socket(name="Geometry", in_out='INPUT', socket_type='NodeSocketGeometry')
    node_group.interface.new_socket(name="Geometry", in_out='OUTPUT', socket_type='NodeSocketGeometry')
    
    # Create group input and output nodes
    group_input = node_group.nodes.new("NodeGroupInput")
    group_input.location = (-300, 0)
    group_output = node_group.nodes.new("NodeGroupOutput")
    group_output.location = (600, 0)
    
    # Create Instance on Points node
    instance_node = node_group.nodes.new("GeometryNodeInstanceOnPoints")
    instance_node.location = (0, 0)
    
    # Create Object Info node to bring in the particle object as instance
    object_info_node = node_group.nodes.new("GeometryNodeObjectInfo")
    object_info_node.location = (-200, -200)
    object_info_node.inputs[0].default_value = particle_obj

    # Create a dedicated Material node that will output the material generated by the addon.
    material_node = node_group.nodes.new("GeometryNodeInputMaterial")
    material_node.location = (-100, 200)
    material_node.material = material

    # Create the Set Material node, which applies the material to the instances.
    set_material_node = node_group.nodes.new("GeometryNodeSetMaterial")
    set_material_node.location = (300, 0)

    # Link nodes:
    node_group.links.new(group_input.outputs["Geometry"], instance_node.inputs["Points"])
    node_group.links.new(object_info_node.outputs["Geometry"], instance_node.inputs["Instance"])
    node_group.links.new(instance_node.outputs["Instances"], set_material_node.inputs["Geometry"])
    node_group.links.new(material_node.outputs["Material"], set_material_node.inputs["Material"])
    node_group.links.new(set_material_node.outputs["Geometry"], group_output.inputs["Geometry"])
    
    modifier = obj.modifiers.new("OptimizedParticleInstancer", 'NODES')
    modifier.node_group = node_group


class CHAOS_OT_generate_animation(Operator):
    """Generate chaotic attractors in multiple modes, including particle trail, particle animation, parameter animation, etc."""
    bl_idname = "chaos.generate_animation"
    bl_label = "Generate Chaotic"
    bl_options = {'REGISTER'}

    def execute(self, context):
        start_time = time.time()
        scn = context.scene
        scn.chaos_live_preview = False
        mode           = scn.chaos_mode
        attractor_type = scn.chaos_attractor_type
        num_frames     = scn.chaos_num_frames
        dt             = scn.chaos_dt
        speed_factor   = scn.chaos_anim_speed
        # Compute final timeline frame (for non-optimized modes)
        final_frame    = int(num_frames / speed_factor)
        if final_frame < 1:
            final_frame = 1

        color_min = scn.chaos_color_min
        color_max = scn.chaos_color_max
        sigma = scn.chaos_sigma
        rho   = scn.chaos_rho
        beta  = scn.chaos_beta
        a_val = scn.chaos_a
        b_val = scn.chaos_b
        c_val = scn.chaos_c
        d_val = scn.chaos_d
        e_val = scn.chaos_e
        f_val = scn.chaos_f
        eqn_x = scn.chaos_eqn_x
        eqn_y = scn.chaos_eqn_y
        eqn_z = scn.chaos_eqn_z
        thomas_b = scn.chaos_thomas_b
        lang_a = scn.chaos_lang_a
        lang_b = scn.chaos_lang_b
        lang_c = scn.chaos_lang_c
        lang_d = scn.chaos_lang_d
        lang_e = scn.chaos_lang_e
        lang_f = scn.chaos_lang_f
        dad_a = scn.chaos_dad_a
        dad_b = scn.chaos_dad_b
        dad_c = scn.chaos_dad_c
        dad_d = scn.chaos_dad_d
        dad_e = scn.chaos_dad_e
        fw_a = scn.chaos_fw_a
        fw_b = scn.chaos_fw_b
        fw_c = scn.chaos_fw_c
        sp_a = scn.chaos_sp_a
        sp_b = scn.chaos_sp_b
        halv_a = scn.chaos_halv_a
        l83_a = scn.chaos_l83_a
        l83_b = scn.chaos_l83_b
        l83_f = scn.chaos_l83_f
        l83_g = scn.chaos_l83_g
        scale_factor = scn.chaos_scale
        origin = bpy.context.scene.cursor.location.copy()
        shape = scn.chaos_particle_shape
        segs = scn.chaos_sphere_segments
        rings = scn.chaos_sphere_rings
        cube_subdiv = scn.chaos_cube_subdiv
        part_size = scn.chaos_particle_size
        bevel_depth = scn.chaos_bevel_depth
        chaos_collection = get_chaos_collection()

        use_color_range = scn.chaos_use_color_range
        use_emission = scn.chaos_use_emission
        emission_str = scn.chaos_emission_strength

        if scn.chaos_use_custom_material and scn.chaos_custom_material is not None:
            mat = scn.chaos_custom_material
        elif scn.chaos_use_color_range:
            color = scn.chaos_color_min
            mat = materials.create_uniform_material(color, scn.chaos_use_emission, scn.chaos_emission_strength)
        else:
            color = scn.chaos_color
            mat = materials.create_uniform_material(color, scn.chaos_use_emission, scn.chaos_emission_strength)

        if use_color_range:
            color_range_materials = []
            for i in range(10):
                t = i / 9.0
                r = color_min[0]*(1-t) + color_max[0]*t
                g = color_min[1]*(1-t) + color_max[1]*t
                b = color_min[2]*(1-t) + color_max[2]*t
                mat_temp = bpy.data.materials.new(f"ChaoticMat_Rand_{i}")
                mat_temp.use_nodes = True
                nt = mat_temp.node_tree
                nodes = nt.nodes
                links = nt.links
                nodes.clear()
                out_node = nodes.new(type='ShaderNodeOutputMaterial')
                out_node.location = (400, 0)
                bsdf = nodes.new(type='ShaderNodeBsdfPrincipled')
                bsdf.location = (0, 0)
                bsdf.inputs["Base Color"].default_value = (r, g, b, 1.0)
                if not use_emission:
                    links.new(bsdf.outputs["BSDF"], out_node.inputs["Surface"])
                else:
                    emission_node = nodes.new(type='ShaderNodeEmission')
                    emission_node.location = (0, -150)
                    emission_node.inputs["Color"].default_value = (r, g, b, 1.0)
                    emission_node.inputs["Strength"].default_value = emission_str
                    add_node = nodes.new(type='ShaderNodeAddShader')
                    add_node.location = (200, 0)
                    links.new(bsdf.outputs["BSDF"], add_node.inputs[0])
                    links.new(emission_node.outputs["Emission"], add_node.inputs[1])
                    links.new(add_node.outputs["Shader"], out_node.inputs["Surface"])
                color_range_materials.append(mat_temp)
        else:
            uniform_mat = materials.create_uniform_material(scn.chaos_color, use_emission, emission_str)

        if scn.chaos_use_custom_material and scn.chaos_custom_material is not None:
            chosen_mat = scn.chaos_custom_material
        else:
            chosen_mat = None

        # ########################################################################################################
        # Optimized Mode for PARTICLE_ANIMATION (Onâ€‘Demand Computation)
        # ########################################################################################################
        if mode == 'PARTICLE_ANIMATION' and scn.chaos_optimized_mode:
            num_particles = scn.chaos_num_particles
            state = attractors.initialize_on_demand_simulation(
                attractor_type,
                num_particles,
                dt,
                sigma, rho, beta,
                a_val, b_val, c_val,
                thomas_b,
                lang_a, lang_b, lang_c, lang_d, lang_e, lang_f,
                dad_a, dad_b, dad_c, dad_d, dad_e,
                fw_a, fw_b, fw_c,
                sp_a, sp_b,
                halv_a,
                l83_a, l83_b, l83_f, l83_g,
                eqn_x, eqn_y, eqn_z,
                d_val, e_val, f_val,
                scn.chaos_offset_scale,
                origin,
                scale_factor,
                scn.chaos_rot_x, scn.chaos_rot_y, scn.chaos_rot_z,
                speed_factor
            )
            # Create particle object
            if shape == 'CUSTOM':
                if scn.chaos_custom_particle is None:
                    self.report({'ERROR'}, "No custom object selected for particles")
                    return {'CANCELLED'}
                base_particle = scn.chaos_custom_particle
            elif shape == 'SPHERE':
                bpy.ops.mesh.primitive_uv_sphere_add(segments=segs, ring_count=rings,
                                                    radius=part_size,
                                                    location=(0, 0, 0))
                base_particle = bpy.context.active_object
            elif shape == 'CUBE':
                bpy.ops.mesh.primitive_cube_add(size=part_size, location=(0, 0, 0))
                base_particle = bpy.context.active_object
                if cube_subdiv > 0:
                    sub_mod = base_particle.modifiers.new("Subdiv", 'SUBSURF')
                    sub_mod.levels = cube_subdiv
                    sub_mod.render_levels = cube_subdiv
            if base_particle.name in bpy.context.collection.objects:
                bpy.context.collection.objects.unlink(base_particle)
            # Create a new mesh for the instanced particles using the initial positions.
            mesh = bpy.data.meshes.new("Optimized_Particles")
            # Set up vertices from the initial state
            x0, y0, z0 = state["initial_state"]
            verts = [tuple(np.array([x0[i], y0[i], z0[i]])) for i in range(num_particles)]
            mesh.from_pydata(verts, [], [])
            optimized_obj = bpy.data.objects.new("Optimized_Particles_Obj", mesh)
            chaos_collection.objects.link(optimized_obj)
            create_geometry_nodes_instancer(optimized_obj, base_particle, mat)
            # Store the on-demand simulation state in the global dictionary.
            handlers.store_optimized_data(optimized_obj.name, state)
            end_time = time.time()
            scn.chaos_last_run_time = end_time - start_time
            self.report({'INFO'}, f"Optimized on-demand mode: Created {num_particles} instanced particles for {attractor_type} in {scn.chaos_last_run_time:.3f} seconds.")
            return {'FINISHED'}

        # ########################################################################################################
        # Mode: PARTICLE_TRAIL_ANIMATION (non-optimized)
        # ########################################################################################################
        if mode == 'PARTICLE_TRAIL_ANIMATION':
            num_particles = scn.chaos_num_particles
            offset_scale = scn.chaos_offset_scale
            if shape == 'CUSTOM':
                if scn.chaos_custom_particle is None:
                    self.report({'ERROR'}, "No custom object selected for particles")
                    return {'CANCELLED'}
                base_particle = scn.chaos_custom_particle.copy()
                base_particle.data = scn.chaos_custom_particle.data.copy()
            elif shape == 'SPHERE':
                bpy.ops.mesh.primitive_uv_sphere_add(segments=segs, ring_count=rings,
                                                      radius=part_size,
                                                      location=(0, 0, 0))
                base_particle = bpy.context.active_object
            elif shape == 'CUBE':
                bpy.ops.mesh.primitive_cube_add(size=part_size, location=(0, 0, 0))
                base_particle = bpy.context.active_object
                if cube_subdiv > 0:
                    sub_mod = base_particle.modifiers.new("Subdiv", 'SUBSURF')
                    sub_mod.levels = cube_subdiv
                    sub_mod.render_levels = cube_subdiv
            if base_particle.name in bpy.context.collection.objects:
                bpy.context.collection.objects.unlink(base_particle)
            for p in range(num_particles):
                x_init = 0.1 + random.uniform(-offset_scale, offset_scale)
                y_init = 0.11 + random.uniform(-offset_scale, offset_scale)
                z_init = 0.12 + random.uniform(-offset_scale, offset_scale)
                points = simulation.generate_points(
                    attractor_type, num_frames, dt,
                    sigma, rho, beta,
                    a_val, b_val, c_val,
                    scn.chaos_eqn_x, scn.chaos_eqn_y, scn.chaos_eqn_z,
                    d_val, e_val, f_val,
                    thomas_b,
                    lang_a, lang_b, lang_c, lang_d, lang_e, lang_f,
                    dad_a, dad_b, dad_c, dad_d, dad_e,
                    fw_a, fw_b, fw_c,
                    sp_a, sp_b,
                    halv_a,
                    l83_a, l83_b, l83_f, l83_g,
                    x0=x_init, y0=y_init, z0=z_init
                )
                points = simulation.rotate_points(points, scn.chaos_rot_x, scn.chaos_rot_y, scn.chaos_rot_z)
                if scale_factor != 1.0:
                    points = [(xx * scale_factor, yy * scale_factor, zz * scale_factor) for (xx, yy, zz) in points]
                points = [(xx + origin[0], yy + origin[1], zz + origin[2]) for (xx, yy, zz) in points]
                if shape == 'CUSTOM':
                    if base_particle.data.materials:
                        local_mat = base_particle.data.materials[0]
                    else:
                        local_mat = chosen_mat if chosen_mat is not None else (random.choice(color_range_materials) if use_color_range else uniform_mat)
                else:
                    if chosen_mat is not None:
                        local_mat = chosen_mat
                    elif use_color_range:
                        local_mat = random.choice(color_range_materials)
                    else:
                        local_mat = uniform_mat
                part_obj = base_particle.copy()
                if shape != 'CUSTOM':
                    if use_color_range:
                        part_obj.data = base_particle.data.copy()
                    else:
                        part_obj.data = base_particle.data
                if shape == 'CUSTOM':
                    part_obj.scale = (part_size, part_size, part_size)
                part_obj.location = points[0]
                chaos_collection.objects.link(part_obj)
                part_obj.name = f"{attractor_type}_Particle_{p}"
                if part_obj.data.materials:
                    part_obj.data.materials[0] = local_mat
                else:
                    part_obj.data.materials.append(local_mat)
                curve_data = bpy.data.curves.new(f"{attractor_type}_Curve_Trail_{p}", type='CURVE')
                curve_data.dimensions = '3D'
                curve_data.bevel_depth = bevel_depth
                if scn.chaos_line_smooth:
                    spl = curve_data.splines.new('BEZIER')
                    spl.bezier_points.add(len(points) - 1)
                    for i, (xx, yy, zz) in enumerate(points):
                        bp = spl.bezier_points[i]
                        bp.co = (xx, yy, zz)
                        bp.handle_left_type = 'AUTO'
                        bp.handle_right_type = 'AUTO'
                    spl.resolution_u = scn.chaos_line_resolution
                else:
                    spl = curve_data.splines.new('POLY')
                    spl.points.add(len(points) - 1)
                    for i, (xx, yy, zz) in enumerate(points):
                        spl.points[i].co = (xx, yy, zz, 1.0)
                curve_obj = bpy.data.objects.new(f"{attractor_type}_TrailLine_{p}", curve_data)
                chaos_collection.objects.link(curve_obj)
                if scn.chaos_use_custom_material and scn.chaos_custom_material is not None:
                    local_mat_curve = scn.chaos_custom_material
                elif use_color_range:
                    local_mat_curve = random.choice(color_range_materials)
                else:
                    local_mat_curve = uniform_mat
                if not curve_data.materials:
                    curve_data.materials.append(local_mat_curve)
                else:
                    curve_data.materials[0] = local_mat_curve
                curve_data.use_map_taper = False
                total_pts = len(points)
                curve_data.use_fill_caps = True
                for i, (xx, yy, zz) in enumerate(points):
                    offset = (p * scn.chaos_release_offset) if scn.chaos_stagger_release else 0
                    frame = int((i + 1) * (final_frame / num_frames)) + offset
                    if frame < 1:
                        frame = 1
                    part_obj.location = (xx, yy, zz)
                    part_obj.keyframe_insert(data_path="location", frame=frame)
                    if scn.chaos_follow_curve:
                        if i < len(points) - 1:
                            tangent = (mathutils.Vector(points[i+1]) - mathutils.Vector((xx, yy, zz))).normalized()
                        elif i > 0:
                            tangent = (mathutils.Vector((xx, yy, zz)) - mathutils.Vector(points[i-1])).normalized()
                        else:
                            tangent = mathutils.Vector((0, 1, 0))
                        rot_quat = tangent.to_track_quat('Y', 'Z')
                        part_obj.rotation_euler = rot_quat.to_euler()
                        part_obj.keyframe_insert(data_path="rotation_euler", frame=frame)
            scn.frame_start = 1
            scn.frame_end = final_frame
            scn.frame_set(1)
            self.report({'INFO'}, f"Created {num_particles} trailing particles for {attractor_type}.")
        # ########################################################################################################
        # Mode: PARTICLE_ANIMATION (non-optimized)
        # ########################################################################################################
        elif mode == 'PARTICLE_ANIMATION':
            num_particles = scn.chaos_num_particles
            offset_scale = scn.chaos_offset_scale
            if shape == 'CUSTOM':
                if scn.chaos_custom_particle is None:
                    self.report({'ERROR'}, "No custom object selected for particles")
                    return {'CANCELLED'}
                base_particle = scn.chaos_custom_particle.copy()
                base_particle.data = scn.chaos_custom_particle.data.copy()
            elif shape == 'SPHERE':
                bpy.ops.mesh.primitive_uv_sphere_add(segments=segs, ring_count=rings,
                                                      radius=part_size,
                                                      location=(0, 0, 0))
                base_particle = bpy.context.active_object
            elif shape == 'CUBE':
                bpy.ops.mesh.primitive_cube_add(size=part_size, location=(0, 0, 0))
                base_particle = bpy.context.active_object
                if cube_subdiv > 0:
                    sub_mod = base_particle.modifiers.new("Subdiv", 'SUBSURF')
                    sub_mod.levels = cube_subdiv
                    sub_mod.render_levels = cube_subdiv
            if base_particle.name in bpy.context.collection.objects:
                bpy.context.collection.objects.unlink(base_particle)
            for p in range(num_particles):
                x_init = 0.1 + random.uniform(-offset_scale, offset_scale)
                y_init = 0.11 + random.uniform(-offset_scale, offset_scale)
                z_init = 0.12 + random.uniform(-offset_scale, offset_scale)
                points = simulation.generate_points(
                    attractor_type, num_frames, dt,
                    sigma, rho, beta,
                    a_val, b_val, c_val,
                    eqn_x, eqn_y, eqn_z,
                    d_val, e_val, f_val,
                    thomas_b,
                    lang_a, lang_b, lang_c, lang_d, lang_e, lang_f,
                    dad_a, dad_b, dad_c, dad_d, dad_e,
                    fw_a, fw_b, fw_c,
                    sp_a, sp_b,
                    halv_a,
                    l83_a, l83_b, l83_f, l83_g,
                    x0=x_init, y0=y_init, z0=z_init
                )
                points = simulation.rotate_points(points, scn.chaos_rot_x, scn.chaos_rot_y, scn.chaos_rot_z)
                if scale_factor != 1.0:
                    points = [(xx * scale_factor, yy * scale_factor, zz * scale_factor) for (xx, yy, zz) in points]
                points = [(xx + origin[0], yy + origin[1], zz + origin[2]) for (xx, yy, zz) in points]
                if shape == 'CUSTOM':
                    if base_particle.data.materials:
                        local_mat = base_particle.data.materials[0]
                    else:
                        local_mat = chosen_mat if chosen_mat is not None else (random.choice(color_range_materials) if use_color_range else uniform_mat)
                else:
                    if chosen_mat is not None:
                        local_mat = chosen_mat
                    elif use_color_range:
                        local_mat = random.choice(color_range_materials)
                    else:
                        local_mat = uniform_mat
                part_obj = base_particle.copy()
                if shape != 'CUSTOM':
                    if use_color_range:
                        part_obj.data = base_particle.data.copy()
                    else:
                        part_obj.data = base_particle.data
                if shape == 'CUSTOM':
                    part_obj.scale = (part_size, part_size, part_size)
                part_obj.location = points[0]
                chaos_collection.objects.link(part_obj)
                part_obj.name = f"{attractor_type}_Particle_{p}"
                if part_obj.data.materials:
                    part_obj.data.materials[0] = local_mat
                else:
                    part_obj.data.materials.append(local_mat)
                for i, (xx, yy, zz) in enumerate(points):
                    offset = (p * scn.chaos_release_offset) if scn.chaos_stagger_release else 0
                    frame = int((i + 1) * (final_frame / num_frames)) + offset
                    if frame < 1:
                        frame = 1
                    part_obj.location = (xx, yy, zz)
                    part_obj.keyframe_insert(data_path="location", frame=frame)
                    if scn.chaos_follow_curve:
                        if i < len(points) - 1:
                            tangent = (mathutils.Vector(points[i+1]) - mathutils.Vector((xx, yy, zz))).normalized()
                        elif i > 0:
                            tangent = (mathutils.Vector((xx, yy, zz)) - mathutils.Vector(points[i-1])).normalized()
                        else:
                            tangent = mathutils.Vector((0, 1, 0))
                        rot_quat = tangent.to_track_quat('Y', 'Z')
                        part_obj.rotation_euler = rot_quat.to_euler()
                        part_obj.keyframe_insert(data_path="rotation_euler", frame=frame)
            scn.frame_start = 1
            scn.frame_end = final_frame
            scn.frame_set(1)
            self.report({'INFO'}, f"Created {num_particles} particles for {attractor_type}.")

        # ########################################################################################################
        # Mode: PARAMETER_ANIMATION
        # ########################################################################################################
        elif mode == 'PARAMETER_ANIMATION':
            if attractor_type == 'CUSTOM':
                self.report({'ERROR'}, "Custom attractors are not supported in Parameter Animation mode.")
                return {'CANCELLED'}
            anim_frames = scn.chaos_animation_frames
            num_points = scn.chaos_num_frames
            curve_name = f"{attractor_type}_Curve_ParameterAnimation"
            curve_data = bpy.data.curves.new(curve_name, type='CURVE')
            curve_data.dimensions = '3D'
            curve_data.bevel_depth = bevel_depth
            spline = curve_data.splines.new('POLY')
            spline.points.add(num_points - 1)
            curve_obj = bpy.data.objects.new(curve_name, curve_data)
            chaos_collection.objects.link(curve_obj)
            
            if scn.chaos_use_custom_material and scn.chaos_custom_material is not None:
                local_mat_line = scn.chaos_custom_material
            elif use_color_range:
                local_mat_line = random.choice(color_range_materials)
            else:
                local_mat_line = uniform_mat
            if not curve_data.materials:
                curve_data.materials.append(local_mat_line)
            else:
                curve_data.materials[0] = local_mat_line

            for frame in range(1, anim_frames + 1):
                scn.frame_set(frame)
                t = (frame - 1) / (anim_frames - 1) if anim_frames > 1 else 0
                if attractor_type == 'LORENZ':
                    sigma_cur = scn.chaos_sigma_start + t * (scn.chaos_sigma_end - scn.chaos_sigma_start)
                    rho_cur   = scn.chaos_rho_start   + t * (scn.chaos_rho_end - scn.chaos_rho_start)
                    beta_cur  = scn.chaos_beta_start  + t * (scn.chaos_beta_end - scn.chaos_beta_start)
                    points = simulation.generate_points('LORENZ', num_points, dt, sigma_cur, rho_cur, beta_cur,
                              a_val, b_val, c_val,
                              eqn_x, eqn_y, eqn_z,
                              d_val, e_val, f_val,
                              thomas_b,
                              lang_a, lang_b, lang_c, lang_d, lang_e, lang_f,
                              dad_a, dad_b, dad_c, dad_d, dad_e,
                              fw_a, fw_b, fw_c,
                              sp_a, sp_b,
                              halv_a,
                              l83_a, l83_b, l83_f, l83_g,
                              x0=0.1, y0=0.11, z0=0.12)
                elif attractor_type == 'ROSSLER':
                    a_cur = scn.chaos_a_start + t * (scn.chaos_a_end - scn.chaos_a_start)
                    b_cur = scn.chaos_b_start + t * (scn.chaos_b_end - scn.chaos_b_start)
                    c_cur = scn.chaos_c_start + t * (scn.chaos_c_end - scn.chaos_c_start)
                    points = simulation.generate_points('ROSSLER', num_points, dt, sigma, rho, beta,
                              a_cur, b_cur, c_cur,
                              eqn_x, eqn_y, eqn_z,
                              d_val, e_val, f_val,
                              thomas_b,
                              lang_a, lang_b, lang_c, lang_d, lang_e, lang_f,
                              dad_a, dad_b, dad_c, dad_d, dad_e,
                              fw_a, fw_b, fw_c,
                              sp_a, sp_b,
                              halv_a,
                              l83_a, l83_b, l83_f, l83_g,
                              x0=0.1, y0=0.11, z0=0.12)
                elif attractor_type == 'THOMAS':
                    thomas_b_cur = scn.chaos_thomas_b_start + t * (scn.chaos_thomas_b_end - scn.chaos_thomas_b_start)
                    points = simulation.generate_points('THOMAS', num_points, dt, sigma, rho, beta,
                              a_val, b_val, c_val,
                              eqn_x, eqn_y, eqn_z,
                              d_val, e_val, f_val,
                              thomas_b_cur,
                              lang_a, lang_b, lang_c, lang_d, lang_e, lang_f,
                              dad_a, dad_b, dad_c, dad_d, dad_e,
                              fw_a, fw_b, fw_c,
                              sp_a, sp_b,
                              halv_a,
                              l83_a, l83_b, l83_f, l83_g,
                              x0=0.1, y0=0.11, z0=0.12)
                # ... Continue with other attractors similarly
                for i, (xx, yy, zz) in enumerate(points):
                    spline.points[i].co = (xx, yy, zz, 1.0)
                    spline.points[i].keyframe_insert(data_path="co", frame=frame)
            scn.frame_start = 1
            scn.frame_end = anim_frames
            scn.frame_set(1)
            self.report({'INFO'}, f"Created parameter animation for {attractor_type} over {anim_frames} frames.")
        # ########################################################################################################
        # Mode: LINE_STATIC (default static line)
        # ########################################################################################################
        else:
            x_init = 0.1
            y_init = 0.11
            z_init = 0.12
            points = simulation.generate_points(
                attractor_type, num_frames, dt,
                sigma, rho, beta,
                a_val, b_val, c_val,
                eqn_x, eqn_y, eqn_z,
                d_val, e_val, f_val,
                thomas_b,
                lang_a, lang_b, lang_c,
                lang_d, lang_e, lang_f,
                dad_a, dad_b, dad_c, dad_d, dad_e,
                fw_a, fw_b, fw_c,
                sp_a, sp_b,
                halv_a,
                l83_a, l83_b, l83_f, l83_g,
                x0=x_init, y0=y_init, z0=z_init
            )
            points = simulation.rotate_points(points, scn.chaos_rot_x, scn.chaos_rot_y, scn.chaos_rot_z)
            if scn.chaos_scale != 1.0:
                points = [(xx*scn.chaos_scale, yy*scn.chaos_scale, zz*scn.chaos_scale) for (xx, yy, zz) in points]
            points = [(xx + origin[0], yy + origin[1], zz + origin[2]) for (xx, yy, zz) in points]
            curve_data = bpy.data.curves.new(f"{attractor_type}_Curve_Static", type='CURVE')
            curve_data.dimensions = '3D'
            curve_data.bevel_depth = bevel_depth
            if scn.chaos_line_smooth:
                spl = curve_data.splines.new('BEZIER')
                spl.bezier_points.add(len(points) - 1)
                for i, (xx, yy, zz) in enumerate(points):
                    bp = spl.bezier_points[i]
                    bp.co = (xx, yy, zz)
                    bp.handle_left_type = 'AUTO'
                    bp.handle_right_type = 'AUTO'
                spl.resolution_u = scn.chaos_line_resolution
            else:
                spl = curve_data.splines.new('POLY')
                spl.points.add(len(points) - 1)
                for i, (xx, yy, zz) in enumerate(points):
                    spl.points[i].co = (xx, yy, zz, 1.0)
            curve_obj = bpy.data.objects.new(f"{attractor_type}_Line_Static", curve_data)
            chaos_collection.objects.link(curve_obj)
            if scn.chaos_use_custom_material and scn.chaos_custom_material is not None:
                local_mat_line = scn.chaos_custom_material
            elif use_color_range:
                local_mat_line = random.choice(color_range_materials)
            else:
                local_mat_line = uniform_mat
            if not curve_data.materials:
                curve_data.materials.append(local_mat_line)
            else:
                curve_data.materials[0] = local_mat_line
            self.report({'INFO'}, f"Created static line for {attractor_type}.")
        end_time = time.time()
        scn.chaos_last_run_time = end_time - start_time
        return {'FINISHED'}


class CHAOS_OT_clear_scene(Operator):
    """Remove objects created by this add-on (and the materials)."""
    bl_idname = "chaos.clear_scene"
    bl_label = "Clear Scene"

    def execute(self, context):
        for obj in list(bpy.data.objects):
            nm = obj.name
            if (nm.startswith("PARTICLE_") or nm.startswith("LORENZ_") or nm.startswith("ROSSLER_") or
                nm.startswith("CUSTOM_") or nm.startswith("THOMAS_") or nm.startswith("LANGFORD_") or
                nm.startswith("DADRAS_") or nm.startswith("FOURWING_") or nm.startswith("SPROTT_") or
                nm.startswith("HALVORSEN_") or nm.startswith("LORENZ83_") or nm.startswith("ARNEODO_") or
                nm.startswith("RUCKLIDGE_") or nm.startswith("Optimized_Particles")):
                bpy.data.objects.remove(obj, do_unlink=True)
        for mat in list(bpy.data.materials):
            if mat.name.startswith("ChaoticMat_Rand") or mat.name.startswith("ChaoticMat_Uniform"):
                bpy.data.materials.remove(mat, do_unlink=True)
        handlers.clear_optimized_data()
        self.report({'INFO'}, "Scene and related Chaotic materials have been cleared.")
        return {'FINISHED'}


class CHAOS_OT_save_last(Operator):
    """Save the last generated attractors by renaming them so they are not cleared."""
    bl_idname = "chaos.save_last"
    bl_label = "Save Last"

    def execute(self, context):
        obj_prefixes = ("PARTICLE_", "LORENZ_", "ROSSLER_", "CUSTOM_", "THOMAS_", "LANGFORD_", "DADRAS_", "FOURWING_", "SPROTT_", "HALVORSEN_", "LORENZ83_", "ARNEODO_", "RUCKLIDGE_", "Optimized_Particles")
        saved_count = 0
        for obj in bpy.data.objects:
            for prefix in obj_prefixes:
                if obj.name.startswith(prefix) and not obj.name.startswith("SAVED_"):
                    obj.name = "SAVED_" + obj.name
                    saved_count += 1
                    break
        mat_prefixes = ("ChaoticMat_Rand", "ChaoticMat_Uniform")
        for mat in bpy.data.materials:
            for prefix in mat_prefixes:
                if mat.name.startswith(prefix) and not mat.name.startswith("SAVED_"):
                    mat.name = "SAVED_" + mat.name
                    break
        self.report({'INFO'}, f"Saved {saved_count} objects and their materials from the last generation.")
        return {'FINISHED'}


class CHAOS_OT_reset_defaults(Operator):
    """Reset all parameters to initial default values."""
    bl_idname = "chaos.reset_defaults"
    bl_label = "Reset Defaults"

    def execute(self, context):
        scn = context.scene
        scn.chaos_use_color_range = False
        scn.chaos_color = (1, 1, 1)
        scn.chaos_color_min = (0, 0.5, 1)
        scn.chaos_color_max = (0.5, 0, 0.5)
        scn.chaos_mode = 'PARTICLE_ANIMATION'
        scn.chaos_attractor_type = 'LORENZ'
        scn.chaos_num_frames = 250
        scn.chaos_dt = 0.01
        scn.chaos_anim_speed = 1.0
        scn.chaos_num_particles = 5
        scn.chaos_offset_scale = 0.02
        scn.chaos_scale = 1.0
        scn.chaos_sigma = 10.0
        scn.chaos_rho = 28.0
        scn.chaos_beta = 2.6667
        scn.chaos_a = 0.2
        scn.chaos_b = 0.2
        scn.chaos_c = 5.7
        scn.chaos_d = 0.0
        scn.chaos_e = 0.0
        scn.chaos_f = 0.0
        scn.chaos_eqn_x = "a*(y - x)"
        scn.chaos_eqn_y = "x*(b - z) - y"
        scn.chaos_eqn_z = "x*y - c*z"
        scn.chaos_thomas_b = 0.208186
        scn.chaos_lang_a = 0.95
        scn.chaos_lang_b = 0.7
        scn.chaos_lang_c = 0.6
        scn.chaos_lang_d = 3.5
        scn.chaos_lang_e = 0.25
        scn.chaos_lang_f = 0.1
        scn.chaos_dad_a = 3.0
        scn.chaos_dad_b = 2.7
        scn.chaos_dad_c = 1.7
        scn.chaos_dad_d = 2.0
        scn.chaos_dad_e = 9.0
        scn.chaos_fw_a_start = 0.2
        scn.chaos_fw_a_end = 0.2
        scn.chaos_fw_b_start = 0.01
        scn.chaos_fw_b_end = 0.01
        scn.chaos_fw_c_start = -0.4
        scn.chaos_fw_c_end = -0.4
        scn.chaos_sp_a_start = 2.07
        scn.chaos_sp_a_end = 2.07
        scn.chaos_sp_b_start = 1.79
        scn.chaos_sp_b_end = 1.79
        scn.chaos_halv_a_start = 1.89
        scn.chaos_halv_a_end = 1.89
        scn.chaos_l83_a_start = 0.95
        scn.chaos_l83_a_end = 0.95
        scn.chaos_l83_b_start = 7.91
        scn.chaos_l83_b_end = 7.91
        scn.chaos_l83_f_start = 4.83
        scn.chaos_l83_f_end = 4.83
        scn.chaos_l83_g_start = 4.66
        scn.chaos_l83_g_end = 4.66
        self.report({'INFO'}, "All Chaotic settings reset to defaults.")
        return {'FINISHED'} 